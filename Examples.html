<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bullet Physics: Examples</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Bullet Physics
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('Examples.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Examples</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A great way to understand bullet physics is through it's examples, I highly recommend building the project directly and running the example browser as you'll be able to look at the source code and then see what it produces.</p>
<h1><a class="anchor" id="basic-example"></a>
Basic Example</h1>
<p>The "Basic Example"'s source code is located at /examples/BasicDemo/BasicExample.cpp, let's list the contents here for simplicity</p>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">Bullet Continuous Collision Detection and Physics Library</span></div>
<div class="line"><span class="comment">Copyright (c) 2015 Google Inc. http://bulletphysics.org</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">This software is provided &#39;as-is&#39;, without any express or implied warranty.</span></div>
<div class="line"><span class="comment">In no event will the authors be held liable for any damages arising from the use of this software.</span></div>
<div class="line"><span class="comment">Permission is granted to anyone to use this software for any purpose, </span></div>
<div class="line"><span class="comment">including commercial applications, and to alter it and redistribute it freely, </span></div>
<div class="line"><span class="comment">subject to the following restrictions:</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.</span></div>
<div class="line"><span class="comment">2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.</span></div>
<div class="line"><span class="comment">3. This notice may not be removed or altered from any source distribution.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;BasicExample.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;btBulletDynamicsCommon.h&quot;</span></div>
<div class="line"><span class="preprocessor">#define ARRAY_SIZE_Y 5</span></div>
<div class="line"><span class="preprocessor">#define ARRAY_SIZE_X 5</span></div>
<div class="line"><span class="preprocessor">#define ARRAY_SIZE_Z 5</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;LinearMath/btVector3.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;LinearMath/btAlignedObjectArray.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;../CommonInterfaces/CommonRigidBodyBase.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>BasicExample : <span class="keyword">public</span> CommonRigidBodyBase</div>
<div class="line">{</div>
<div class="line">    BasicExample(<span class="keyword">struct</span> GUIHelperInterface* helper)</div>
<div class="line">        : CommonRigidBodyBase(helper)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">virtual</span> ~BasicExample() {}</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> initPhysics();</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> renderScene();</div>
<div class="line">    <span class="keywordtype">void</span> resetCamera()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">float</span> dist = 4;</div>
<div class="line">        <span class="keywordtype">float</span> pitch = -35;</div>
<div class="line">        <span class="keywordtype">float</span> yaw = 52;</div>
<div class="line">        <span class="keywordtype">float</span> targetPos[3] = {0, 0, 0};</div>
<div class="line">        m_guiHelper-&gt;resetCamera(dist, yaw, pitch, targetPos[0], targetPos[1], targetPos[2]);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> BasicExample::initPhysics()</div>
<div class="line">{</div>
<div class="line">    m_guiHelper-&gt;setUpAxis(1);</div>
<div class="line"> </div>
<div class="line">    createEmptyDynamicsWorld();</div>
<div class="line">    <span class="comment">//m_dynamicsWorld-&gt;setGravity(btVector3(0,0,0));</span></div>
<div class="line">    m_guiHelper-&gt;createPhysicsDebugDrawer(m_dynamicsWorld);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (m_dynamicsWorld-&gt;getDebugDrawer())</div>
<div class="line">        m_dynamicsWorld-&gt;getDebugDrawer()-&gt;setDebugMode(btIDebugDraw::DBG_DrawWireframe + btIDebugDraw::DBG_DrawContactPoints);</div>
<div class="line"> </div>
<div class="line">    btBoxShape* groundShape = createBoxShape(btVector3(btScalar(50.), btScalar(50.), btScalar(50.)));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//groundShape-&gt;initializePolyhedralFeatures();</span></div>
<div class="line">    <span class="comment">//btCollisionShape* groundShape = new btStaticPlaneShape(btVector3(0,1,0),50);</span></div>
<div class="line"> </div>
<div class="line">    m_collisionShapes.push_back(groundShape);</div>
<div class="line"> </div>
<div class="line">    btTransform groundTransform;</div>
<div class="line">    groundTransform.setIdentity();</div>
<div class="line">    groundTransform.setOrigin(btVector3(0, -50, 0));</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">        btScalar mass(0.);</div>
<div class="line">        createRigidBody(mass, groundTransform, groundShape, btVector4(0, 0, 1, 1));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//create a few dynamic rigidbodies</span></div>
<div class="line">        <span class="comment">// Re-using the same collision is better for memory usage and performance</span></div>
<div class="line"> </div>
<div class="line">        btBoxShape* colShape = createBoxShape(btVector3(.1, .1, .1));</div>
<div class="line"> </div>
<div class="line">        <span class="comment">//btCollisionShape* colShape = new btSphereShape(btScalar(1.));</span></div>
<div class="line">        m_collisionShapes.push_back(colShape);</div>
<div class="line"> </div>
<div class="line">        btTransform startTransform;</div>
<div class="line">        startTransform.setIdentity();</div>
<div class="line"> </div>
<div class="line">        btScalar mass(1.f);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">//rigidbody is dynamic if and only if mass is non zero, otherwise static</span></div>
<div class="line">        <span class="keywordtype">bool</span> isDynamic = (mass != 0.f);</div>
<div class="line"> </div>
<div class="line">        btVector3 localInertia(0, 0, 0);</div>
<div class="line">        <span class="keywordflow">if</span> (isDynamic)</div>
<div class="line">            colShape-&gt;calculateLocalInertia(mass, localInertia);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; ARRAY_SIZE_Y; k++)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ARRAY_SIZE_X; i++)</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; ARRAY_SIZE_Z; j++)</div>
<div class="line">                {</div>
<div class="line">                    startTransform.setOrigin(btVector3(</div>
<div class="line">                        btScalar(0.2 * i),</div>
<div class="line">                        btScalar(2 + .2 * k),</div>
<div class="line">                        btScalar(0.2 * j)));</div>
<div class="line"> </div>
<div class="line">                    createRigidBody(mass, startTransform, colShape);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    m_guiHelper-&gt;autogenerateGraphicsObjects(m_dynamicsWorld);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> BasicExample::renderScene()</div>
<div class="line">{</div>
<div class="line">    CommonRigidBodyBase::renderScene();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">CommonExampleInterface* BasicExampleCreateFunc(CommonExampleOptions&amp; options)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> BasicExample(options.m_guiHelper);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">B3_STANDALONE_EXAMPLE(BasicExampleCreateFunc)</div>
</div><!-- fragment --><p>There are two main layers of understanding that need to happen here, firstly we can see that this example has specific code for it's own use like when it creates it's own box collision shape, but also there seems to be many helper functions being used here to make the creation of new examples quite simple.</p>
<p>You'll notice that in most of the example code you'll be able to learn about how to set up ceratin situations directly relating to bullet.</p>
<h1><a class="anchor" id="example-browser"></a>
Example Browser</h1>
<p>The example browser is the best way to see how bullet works and what it's capable of, to run the example browser you should be familiar with building bullet directly which you can read about in the building section.</p>
<p>To operate the example browser simply select the example you're interested in in the left panel.</p>
<ul>
<li>ctrl + mouse click and drag will rotate the camera about the origin</li>
<li>click and drag can move certain objects if they're interactive</li>
<li>s toggles shadows</li>
<li>w toggles wireframe mode</li>
</ul>
<h2><a class="anchor" id="infrastructure"></a>
Infrastructure</h2>
<p>While reading the examples directly will teach you a lot about how bullet works in isolation, learning about how bullet is integrated into real code is another big takeaway from these examples. So we'll start by looking at this.</p>
<p>Before we get started, crack out the source code and be ready to follow along. I find the best way to learn a complex system is to start by running the code ourselves (as if we were running it) and seeing what this execution path interacts with along the way. By picking a good start point you should be able to get a full end to end view of the system.</p>
<h3><a class="anchor" id="loading-in-graphics-data"></a>
Loading in Graphics Data</h3>
<p>First off, you'll probably have noticed <code>m_guiHelper</code> hanging around a bit, it's used at the start to generate the axis, it sets up the toggleable debug drawer in the example browser, and finally auto generates graphics objects before the as a part of the physics initialization method.</p>
<p>You'll be able to locate most of these helpers through the examples/CommonInterfaces directory in the bullet library, and specificially in that directory you can find <code>CommonGUIHelperInterface.h</code> which provides an interface for a gui helper.</p>
<p>If you hadn't recognized yet, the example browser uses opengl to render the examples, and since we've seen that this gui helper has the ability to auto generate graphics objects, it would make sense if it the implementation of the gui helper would be in some opengl related folder, and of course it is. You can locate it at <code>/ExampleBrowser/OpenGLGuiHelper.cpp</code>.</p>
<p>Reading through the implementation of <code>autogenerateGraphicsObjects</code> we find that it iterates through a list of objects calling <code>createCollisionObjectGraphicsObject</code> so we go to it's implementation and see that a few checks are made and then eventually a pretty big call is made to <code>registerGraphicsInstance</code> passing along the id of this shape, it's initial position, rotation, color and scaling. The true call is actually quite lengthy and looks something like this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> graphicsInstanceId = m_data-&gt;m_glApp-&gt;m_renderer-&gt;registerGraphicsInstance(graphicsShapeId, startTransform.getOrigin(), startTransform.getRotation(), color, localScaling);</div>
</div><!-- fragment --><p>When first seeing this call, we can tell that we've hit something important because it seems to go through many objects, and talk to the renderer. We'll first start with what <code>m_glApp</code> is.</p>
<p>We can find out that it's type is <code>CommonGraphicsApp</code>, and one of the implementations of it is in <code>OpenGLWindow/SimpleOpenGL3App.cpp</code>, here we can see that when it is instantiated <code>m_renderer</code> is set to a new <code>GLInstancingRenderer</code> object, which is defined in <code>OpenGLWindow/GLInstancingRenderer.cpp</code>.</p>
<p>At this point we can see the definition of <code>registerGraphicsInstance</code> which was our goal. Looking in it's definition we can see that it simply stores the data passed in into <code>m_data</code> which has the type <code>InternalDataRenderer</code>, this internal data has individual pointers for the positional, rotational, color and scale information so that opengl can use it in the VAO.</p>
<p>This file is actually quite important when it comes to rendering, if we go to the top of the file you can see the vertex and fragment shader source code, additionally it provides various drawing functionalities which take in information and draw it with opengl. Usually this ends up looking like binding any texture samplers using the shader program, binding any matrix uniforms into the shader as well as colors attributes, then the vertex array object is bound and then <code>glDrawArrays</code> is used to finally draw the information, after all that is done the vertex array object is unbound.</p>
<h3><a class="anchor" id="rendering"></a>
Rendering</h3>
<p>At this point we've dug through a few files, and we are getting a fuller understanding of how this system works. One thing that isn't quite clear is that in our original <code>BasicExample.cpp</code> file, we saw nothing to do with the rendering, it simply set up the data and never did anything with it. That tells us that the rendering is being abstracted away somewhere, we do know that our rendering uses opengl, and that that is an iterative animation system so that there will most likely be a main loop calling a function, which eventually updates the graphics.</p>
<p>Following this thread we can take a look at <code>ExampleBrowser/main.cpp</code> which we can assume is the main entry point into the example browser. Inside of this file, we can see that an instance of the class <code>OpenGLExampleBrowser</code> is instantiated, then a bit later we find a do while loop that calls update on this example browser instance. This seems promising so we can take a look inside of <code>ExampleBrowser/OpenGLExampleBrowser.cpp</code>.</p>
<p>Inside of this file we can see the definition of the update method which is a bit of a monster, and could do with a refactor for sure. The main logic is that it verifies what kind of simulation is being run and then based on that it updates the graphics accordingly.</p>
<p>So long as we have loaded up a demo, there are a few options, which are if the simulation is currently paused, if it is a single step simulation (meaning that we only step the simulation for one iteration), if the simulation used a fixed or varying time step, all in all this stage determines how the simulation should be stepped.</p>
<p>Then if we are going to be rendering visual geometry we then call <code>renderScene</code> on the current demo, this rendering component should be what we are after.</p>
<h3><a class="anchor" id="how-it-knows-the-current-demo"></a>
How it Knows the Current Demo (Aside)</h3>
<p>The variable <code>sCurrentDemo</code> is initialized through this line</p>
<div class="fragment"><div class="line">sCurrentDemo = gFileImporterByExtension[i].m_createFunc(options);</div>
</div><!-- fragment --><p>This line resides in the function <code>void openFileDemo(const char* filename)</code>, which is called through a callback when a user selects a demo through the gui, and this function iterates the index i until:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (strstr(fullPath, gFileImporterByExtension[i].m_extension.c_str()))</div>
</div><!-- fragment --><p>Becomes true, and then calls the previous line I mentioned. The call to <code>m_createFunc</code> is imporant, looking at any example and specifically <code>BasicExample.cpp</code> we can see that this call simply creates and returns a new object <code>BasicExample</code> that inherits from the <code>CommonExampleInterface</code>. It can be thought of as a constructor method.</p>
<p>This completes the aside.</p>
<p>Back to rendering, we know that the following call is made: <code>sCurrentDemo-&gt;updateGraphics();</code>, but doing a recursive search ththrough the code base only told that the <code>PhysicsServerExample</code> has an implementation. This means that most likely the instancing renderer is automatically doing the rendering itself.</p>
<h3><a class="anchor" id="instancing-renderer"></a>
Instancing Renderer</h3>
<p>Before we continue with the rendering it's about time we actually crack down on what an instancing renderer is as it keeps coming up, I highly recommend you read learnopengl.com's highly detailed explanation on the topic here: <a href="https://learnopengl.com/Advanced-OpenGL/Instancing">https://learnopengl.com/Advanced-OpenGL/Instancing</a>.</p>
<p>To boil it down quickly, when we render stuff with opengl for a small collection of object we usually just iterate through the objects, each time binding their respective VAO's textures and uniforms before calling an opengl draw method. Even if all the object were the same (perhaps a basic cube), we would still need to do this for each one, this will eventually case a performance bottleneck because of how many draw calls there are as the number of objects increases.</p>
<p>So long as we wish to draw the same object, but with different transformations, we can use glDrawArraysInstanced, which allows us to use the object once, along with a instance count and we can then use this as an index to change the positions of the objects in the shader, this makes it so that we only need one draw call and makes the rendering much faster.</p>
<p>With that out of the way, recall that the instancing renderer is located at <code>OpenGLWindow/GLInstancingRenderer.cpp</code>, here we can find <code>renderScene</code> and <code>renderSceneInternal</code> the latter of which does all the heavy lifting. It can roughly be broken down into the following sections</p>
<ol type="1">
<li>Optionally enable face culling, shadow maps.</li>
<li>Prepare matrices, depth matrix, bias matrix, view and projection matrix</li>
<li>Iterate through transparent objects and store them in an array</li>
<li>Iterate through opaque and then transparent objects 4.1. If this object is a texture load in the texture and create a texture unit for it setting relevant information 4.2. If this object not a texture create a default texture 4.3. Bind a VAO for the current object <code>glBindVertexArray(gfxObj-&gt;m_cube_vao);</code> 4.4. Set up vertex attribute pointers for vertex positions (of the collision shape), position of each instance (or just 1 if one instance), rotations for each instance, uvs, normals, colors of each instance, scale of each instance. 4.5. Enable vertex attribute arrays and bind the indices for the current object's vertices into the VAO</li>
<li>Based on the current render mode each one of which is a choice of shadows, texturing methods, image segmentation (we'll focus on the default render mode) 5.1. load in the shader program 5.2. store the projection, view matrix and lighting information into their shader uniforms 5.3. use <code>glDrawElementsInstanced(GL_TRIANGLES, indexCount, GL_UNSIGNED_INT, indexOffset, gfxObj-&gt;m_numGraphicsInstances);</code> to draw all the instances of this object at once.</li>
</ol>
<p>Note that there is no model matrix required because when we use instancing we draw the same object in different locations by passing an buffer of positions to opengl.</p>
<h2><a class="anchor" id="recap"></a>
Recap</h2>
<p>The way the example browser works is that it defines a common interface for all examples, it has a renderer interface and by defualt it uses the opengl renderer with instanced rendering. The examples create bullet physics objects and then call <code>glDrawElementsInstanced(GL_TRIANGLES, indexCount, GL_UNSIGNED_INT, indexOffset, gfxObj-&gt;m_numGraphicsInstances);</code> which takes all the collision shapes in the current bullet physics simulation and for each one it converts it into a form that is ready for opengl to use.</p>
<p>Then in the main function of the example browser there is a loop that calls update on the example browser which eventually renders everything that was created through the call to <code>autogenerateGraphicsObjects</code>.</p>
<p>The main methods you should check out would be</p>
<ol type="1">
<li><code>void OpenGLGuiHelper::autogenerateGraphicsObjects(btDiscreteDynamicsWorld* rbWorld)</code></li>
<li><code>void OpenGLGuiHelper::createCollisionShapeGraphicsObject(btCollisionShape* collisionShape)</code></li>
<li><code>int OpenGLGuiHelper::registerGraphicsShape(const float* vertices, int numvertices, const int* indices, int numIndices, int primitiveType, int textureId)</code></li>
<li><code>int GLInstancingRenderer::registerShape(const float* vertices, int numvertices, const int* indices, int numIndices, int primitiveType, int textureId)</code> line 1162 in examples/OpenGLWindow/GLInstancingRenderer.cpp</li>
</ol>
<p>In the call to <code>void OpenGLGuiHelper::createCollisionShapeGraphicsObject(btCollisionShape* collisionShape)</code> we can see that if the passed in object is a cube that a standard cube is loaded in through <code>cube_vertices_textured</code>, using a recursive grep search we can see it's defined here <code>/OpenGLWindow/ShapeData.h</code> on line 475, you'll find that these shapes are stored as 1d arrays, but follow a certain ordering based on what extra information is stored in the array such as normals and texture coordinates. From this comment we can see that the objects data is not pulled directly from the collision shape created in bullet but is simply using vertices from a constants file. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
