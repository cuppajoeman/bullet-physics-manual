<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bullet Physics: OpenGL</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Bullet Physics
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('Integrating.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">OpenGL</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>After you've read about the basics of how bullet physics works, you can run your simulation, although it would be great to see what's going on inside of our physics simulation.</p>
<p>Bullet integrates nicely with opengl which is an interface for interacting with your graphics cards, if you're entirely new to opengl, I recommend going through the tutorials you can find on learnopengl.com or by looking at glfw's example.</p>
<p>We won't be going into the specifics of how opengl works, but the main thing is that we need three main transformations for us to human vision and motion of objects, they are the local_to_world, world_to_camera, and the camera_to_clip transformations.</p>
<p>These transformations are executed in the order specified above, so first we have an object like a scoccer ball that has it's origin centered at the middle of the ball, perhaps the soccer ball has been kicked by a player in our game and is moving along a parabolic arc, at a specific moment in time, we know where it's position should be in 3d space we can transform our soccer balls origin to that position by using the local_to_world transformation.</p>
<p>The camera is also at another position in space, and since we want to view things from the camera's perspective we can also consider the camera as the origin, to do this, we have to apply the world_to_camera transformation, and at that point we apply perspective through the camera_to_clip transformation.</p>
<p>With all the transformations out of the way, we can now see how bullet physics can work with OpenGL, so given a physics simulation, we can iterate though every object grab it's local_to_world transformation, which moves the object to the correct location as specified by bullet physics, and then draw it at that location.</p>
<div class="fragment"><div class="line"><span class="comment">// render collsion shapes</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = dynamicsWorld-&gt;getNumCollisionObjects() - 1; j &gt;= 0; j--) {</div>
<div class="line">    btCollisionObject* obj = dynamicsWorld-&gt;getCollisionObjectArray()[j];</div>
<div class="line">    btRigidBody* body = btRigidBody::upcast(obj);</div>
<div class="line">    btTransform transform;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (body &amp;&amp; body-&gt;getMotionState()) {</div>
<div class="line">        body-&gt;getMotionState()-&gt;getWorldTransform(transform);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        transform = obj-&gt;getWorldTransform();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// convert the btTransform into the GLM matrix using &#39;glm::value_ptr&#39;</span></div>
<div class="line">    glm::mat4 model_matrix;</div>
<div class="line">    transform.getOpenGLMatrix(glm::value_ptr(model_matrix));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// model-view-projection</span></div>
<div class="line">    glm::mat4 mvp_mat = g_proj_matrix * g_view_matrix * model_matrix;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (strcmp((obj-&gt;getCollisionShape())-&gt;getName(), <span class="stringliteral">&quot;Box&quot;</span>) == 0)</div>
<div class="line">    {</div>
<div class="line">        glUniform3fv(ColorID, 1, glm::value_ptr(albedoArray[j % 3]));</div>
<div class="line"> </div>
<div class="line">        glUniformMatrix4fv(MatrixID, 1, GL_FALSE, glm::value_ptr(mvp_mat));</div>
<div class="line">        myBox.render();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp((obj-&gt;getCollisionShape())-&gt;getName(), <span class="stringliteral">&quot;SPHERE&quot;</span>) == 0)</div>
<div class="line">    {</div>
<div class="line">        glUniform3fv(ColorID, 1, glm::value_ptr(albedoArray[j % 3]));</div>
<div class="line"> </div>
<div class="line">        glUniformMatrix4fv(MatrixID, 1, GL_FALSE, glm::value_ptr(mvp_mat));</div>
<div class="line">        mySphere.render();</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>You notice that in this code example we compare the name of the collision shape which are defined automatically and then based on what that returns we render a specific object.</p>
<p>While this works fine in this toy example but in the future you might want to support many different objects, and so hard coding if statements will not scale well when you have hundreds of different objects.</p>
<p>One way to approach this is through a collision shapes <code>setUserIndex</code> and <code>getUserIndex</code> calls, which allows you to store arbitrary indices in your physics objects. With that in place you can store a list of models in your main program and then when you iterate through the collision objects, you use the user index to grab the correct model before transforming it to the collision shapes position.</p>
<h1><a class="anchor" id="debug-graphics"></a>
Debug Graphics</h1>
<p>Bullet physics provides methods which you can provide an implementation to and then bullet will automatically make the draw calls for you to help you visualize what's going on in the physics engine.</p>
<p>To do so override btIDebugDraw, implement the drawLine method using OpenGL or your rendering engine and then Bullet will take care of everything else and draw the collision shape on top of whatever is on screen.</p>
<p><a href="https://pybullet.org/Bullet/BulletFull/classbtIDebugDraw.html">https://pybullet.org/Bullet/BulletFull/classbtIDebugDraw.html</a></p>
<p><code>physics_debug_drawer.hpp</code></p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef PHYSICS_DEBUG_DRAWER_HEADER</span></div>
<div class="line"><span class="preprocessor">#define PHYSICS_DEBUG_DRAWER_HEADER</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;LinearMath/btIDebugDraw.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;glm/glm.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;glm/gtc/type_ptr.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;shader_pipeline.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>PhysicsDebugDrawer : <span class="keyword">public</span> btIDebugDraw {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line">    GLuint vertex_buffer_object, vertex_attribute_object;</div>
<div class="line"> </div>
<div class="line">    ShaderPipeline line_shader_pipeline;</div>
<div class="line"> </div>
<div class="line">    PhysicsDebugDrawer(glm::mat4 camera_to_clip, glm::mat4 world_to_camera);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> drawLine(<span class="keyword">const</span> btVector3&amp; from, <span class="keyword">const</span> btVector3&amp; to, <span class="keyword">const</span> btVector3&amp; color);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> drawContactPoint(<span class="keyword">const</span> btVector3 &amp;, <span class="keyword">const</span> btVector3 &amp;, btScalar, <span class="keywordtype">int</span>, <span class="keyword">const</span> btVector3 &amp;) {} <span class="comment">// empty implementation</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> reportErrorWarning(<span class="keyword">const</span> <span class="keywordtype">char</span> *) {} <span class="comment">// empty implementation</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> draw3dText(<span class="keyword">const</span> btVector3 &amp;, <span class="keyword">const</span> <span class="keywordtype">char</span> *) {} <span class="comment">// empty implementation</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> setDebugMode(<span class="keywordtype">int</span> p) {</div>
<div class="line">        m = p;</div>
<div class="line">    } <span class="comment">// empty implementation</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> getDebugMode(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 3; } <span class="comment">// empty implementation</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> m;</div>
<div class="line">};</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p><code>physics_debug_drawer.cpp</code> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;physics_debug_drawer.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line">PhysicsDebugDrawer::PhysicsDebugDrawer(glm::mat4 camera_to_clip, glm::mat4 world_to_camera) {</div>
<div class="line"> </div>
<div class="line">    line_shader_pipeline.load_in_shaders_from_file(<span class="stringliteral">&quot;../shaders/absolute_position.vert&quot;</span>, <span class="stringliteral">&quot;../shaders/absolute_position.frag&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    GLint world_to_camera_uniform_location = glGetUniformLocation(line_shader_pipeline.shader_program_id, <span class="stringliteral">&quot;world_to_camera&quot;</span>);</div>
<div class="line">    glUniformMatrix4fv(world_to_camera_uniform_location, 1, GL_FALSE, glm::value_ptr(world_to_camera));</div>
<div class="line"> </div>
<div class="line">    GLint camera_to_clip_uniform_location = glGetUniformLocation(line_shader_pipeline.shader_program_id, <span class="stringliteral">&quot;camera_to_clip&quot;</span>);</div>
<div class="line">    glUniformMatrix4fv(camera_to_clip_uniform_location, 1, GL_FALSE, glm::value_ptr(camera_to_clip));</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> PhysicsDebugDrawer::drawLine(<span class="keyword">const</span> btVector3&amp; from, <span class="keyword">const</span> btVector3&amp; to, <span class="keyword">const</span> btVector3&amp; color) {</div>
<div class="line">    <span class="comment">// Vertex data</span></div>
<div class="line">    GLfloat points[12];</div>
<div class="line"> </div>
<div class="line">    points[0] = from.x();</div>
<div class="line">    points[1] = from.y();</div>
<div class="line">    points[2] = from.z();</div>
<div class="line">    points[3] = color.x();</div>
<div class="line">    points[4] = color.y();</div>
<div class="line">    points[5] = color.z();</div>
<div class="line"> </div>
<div class="line">    points[6] = to.x();</div>
<div class="line">    points[7] = to.y();</div>
<div class="line">    points[8] = to.z();</div>
<div class="line">    points[9] = color.x();</div>
<div class="line">    points[10] = color.y();</div>
<div class="line">    points[11] = color.z();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Why do we have to do this?</span></div>
<div class="line">    glDeleteBuffers(1, &amp;vertex_buffer_object);</div>
<div class="line">    glDeleteVertexArrays(1, &amp;vertex_attribute_object);</div>
<div class="line"> </div>
<div class="line">    glGenBuffers(1, &amp;vertex_buffer_object);</div>
<div class="line">    glGenVertexArrays(1, &amp;vertex_attribute_object);</div>
<div class="line">    glBindVertexArray(vertex_attribute_object);</div>
<div class="line"> </div>
<div class="line">    glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer_object);</div>
<div class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(points), &amp;points, GL_STATIC_DRAW);</div>
<div class="line"> </div>
<div class="line">    glEnableVertexAttribArray(0);</div>
<div class="line">    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * <span class="keyword">sizeof</span>(GLfloat), 0);</div>
<div class="line"> </div>
<div class="line">    glEnableVertexAttribArray(1);</div>
<div class="line">    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * <span class="keyword">sizeof</span>(GLfloat), (GLvoid*)(3 * <span class="keyword">sizeof</span>(GLfloat)));</div>
<div class="line"> </div>
<div class="line">    glBindVertexArray(0);</div>
<div class="line"> </div>
<div class="line">    glBindVertexArray(vertex_attribute_object);</div>
<div class="line">    glDrawArrays(GL_LINES, 0, 2);</div>
<div class="line">    glBindVertexArray(0);</div>
<div class="line">}</div>
</div><!-- fragment --><p>It's possible that you've noticed, but in our shaders we never bind a <code>local_to_world</code> transformation, the reason why is that the debug drawer uses absolute positions when drawing, if you've learned opengl through learnopengl.com this might be a little weird since you'd be used to moving a collection of vertices (such as a cube) around via a <code>local_to_world</code> transformation rather than changing the actual location of vertices. With that in mind the shader source code should make sense:</p>
<p><code>absolute_position.vert</code></p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 330 core</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// This shader draws vertices at an absolute location rather than using a</span></div>
<div class="line"><span class="comment">// local to world coordinate transformation, it also specifies a color to</span></div>
<div class="line"><span class="comment">// be used during the drawing</span></div>
<div class="line"> </div>
<div class="line">layout (location = 0) in vec3 position;</div>
<div class="line">layout (location = 1) in vec3 color;</div>
<div class="line"> </div>
<div class="line">out vec3 passthrough_color;</div>
<div class="line"> </div>
<div class="line">uniform mat4 camera_to_clip;</div>
<div class="line">uniform mat4 world_to_camera;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main() {</div>
<div class="line">    gl_Position = camera_to_clip * world_to_camera * vec4(position, 1.0f);</div>
<div class="line">    passthrough_color = color;</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>absolute_position.frag</code></p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 330 core</span></div>
<div class="line"> </div>
<div class="line">in vec3 passthrough_color;</div>
<div class="line">out vec4 frag_color;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main()</div>
<div class="line">{</div>
<div class="line">    frag_color = passthrough_color;   </div>
<div class="line">}</div>
</div><!-- fragment --><p>Then in your <code>main.cpp</code> or where ever your main game loop resides you create your debug drawer, register it with bullet and then call the draw method on every iteration. Your implementation may vary, but personally I have a set up like this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    ...</div>
<div class="line"> </div>
<div class="line">    PhysicsDebugDrawer physics_debug_drawer(camera_to_clip, world_to_camera);</div>
<div class="line">    physics.dynamics_world-&gt;setDebugDrawer(&amp;physics_debug_drawer);</div>
<div class="line"> </div>
<div class="line">    ...</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span> (running) {</div>
<div class="line">        ... </div>
<div class="line">        physics.dynamics_world-&gt;debugDrawWorld();</div>
<div class="line">        ...</div>
<div class="line">    }</div>
<div class="line">    ...</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
