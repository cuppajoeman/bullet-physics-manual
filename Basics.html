<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bullet Physics: Basics</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Bullet Physics
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('Basics.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Basics</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>basics</h1>
<h2>expected knowledge</h2>
<p>To get started with bullet physics we have to figure out where it stands with respect to what level of detail is exposed to the user, for example a beginner programmer might hope that there is some <code>simulation = createPhysicsSimulation()</code> function that makes a simulation that automatically updates itself and then we would do <code>simluation.addSphere()</code> and so on, whereas a more advanced programmer would hope for more control from the get go. </p>
<p>This level of detail is also the same as what knowledge the library expects us to have in order for us to use it properly, and in the case of bullet, it's a basic understanding of how a physics engine works. Without this knowledge it will be hard to work with the library </p>
<h3>physics simulation</h3>
<p>To understand how a physics simulation works, let's think of a video game that has gravity, players that can move around, and guns which fire projectiles. </p>
<h4>time</h4>
<p>The first fundamental component of such a system, would be the concept of time, as without it nothing would happen, everything would be frozen in space and nothing would move. We as humans have a hard time grappling about a continuum of time, one way we've found to manage with it is by counting seconds, breaking it down into discreet steps. </p>
<p>We can teach our programs to count by using the while loop that runs continually and then measuring the amount of time that has passed since last iteration. Our physics simulation will also use this concept, moving from one state to another, while updating positions and information based on how much time has passed since last time we updated our simulation. </p>
<h4>collisions</h4>
<p>First things first, we should make sure our players don't fall through the floor when gravity is applied, so our physics engine simulation needs to be able to do collisions, this will also be useful for when two players collide. </p>
<p>Since our physics simulation is written in code, to some extent things will be run sequentially (ignoring any threading for now), and so given two objects, how would we know if they're colliding? Well we could grab one, and then another, and then based on their shape, figure out if they're intersecting in any way, and then we would know if they are colliding. </p>
<h5>efficiency</h5>
<p>Naively we could take this idea, iterate over each of the objects that could collide in our simulation and check for collisions. This is a good first start, but if we had N things that collide we could find a quick upperbound on how that scales up. We would have to check each one of the N objects against the N-1 others, so as the number of objects increases, the time to do these checks would increase at a rate of N^2, which becomes unwieldy </p>
<p><em> Note: by unwieldy I mean your game may become extremely laggy or come to a grinding halt, making an experience that none of your potential players are going to want to experience. </em> </p>
<p>If we had an inexpensive test to quickly rule out objects or groups of objects of having the possibility of colliding, then we could cut down on the number of checks we would have to perform, which would bring our game back from being a laggy mess to a real-time experience. </p>
<p>The great thing is that over the years we've come up with many different solutions on how we can do this </p>
<ul>
<li>
<p class="startli">spatial partitioning: Carve up space and cheaply exclude objects that are in different regions, examples include </p><ul>
<li>
binary space partitioning </li>
<li>
octrees </li>
<li>
grids </li>
</ul>
<p class="endli"></p>
</li>
<li>
<p class="startli">object partitioning: a similar idea to the one before but now the focus is around the space an object takes up rather than the section of space it's in, examples include </p><ul>
<li>
<a href="assets/sphere_trees.pdf">sphere trees</a> </li>
</ul>
<p class="endli"></p>
</li>
<li>
sort and sweep: place the objects in order spatially and rule out collisions between objects that aren't adjacent </li>
</ul>
<p>Since this topic has such significance when it comes to game engines, it has been called <b>broad phase</b> collision detection, and is specifically about how to cut down on the number of collisions that need to be checked for, it also comes with another phase, which is called <b>narrow phase</b> collision detection which corresponds to the actual checking of collisions between objects. </p>
<h4>constraints</h4>
<p>TODO </p>
<h2>back to bullet</h2>
<p>In order for us to start a bullet physics simulation to run, it needs to know a few things: </p>
<ul>
<li>
Would you like to customize any part of the collision detection? </li>
<li>
Please provide me with a dispatcher that will act on your behalf when a collision occurs </li>
<li>
What kind of broadphase algorithm would you like to use? </li>
<li>
What kind of contstraint solving agorithm would you like to use? </li>
</ul>
<p>This translates into the following code:</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;btBulletDynamicsCommon.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> i;</div>
<div class="line"> </div>
<div class="line">    btDefaultCollisionConfiguration* collisionConfiguration = <span class="keyword">new</span> btDefaultCollisionConfiguration();</div>
<div class="line"> </div>
<div class="line">    btCollisionDispatcher* dispatcher = <span class="keyword">new</span> btCollisionDispatcher(collisionConfiguration);</div>
<div class="line"> </div>
<div class="line">    btBroadphaseInterface* overlappingPairCache = <span class="keyword">new</span> btDbvtBroadphase();</div>
<div class="line"> </div>
<div class="line">    btSequentialImpulseConstraintSolver* solver = <span class="keyword">new</span> btSequentialImpulseConstraintSolver;</div>
<div class="line"> </div>
<div class="line">    btDiscreteDynamicsWorld* dynamicsWorld = <span class="keyword">new</span> btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);</div>
<div class="line"> </div>
<div class="line">    dynamicsWorld-&gt;setGravity(btVector3(0, -10, 0));</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">//keep track of the shapes, we release memory at exit.</span></div>
<div class="line">    <span class="comment">//make sure to re-use collision shapes among rigid bodies whenever possible!</span></div>
<div class="line">    btAlignedObjectArray&lt;btCollisionShape*&gt; collisionShapes;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">//the ground is a cube of side 100 at position y = -56.</span></div>
<div class="line">    <span class="comment">//the sphere will hit it at y = -6, with center at -5</span></div>
<div class="line">    {</div>
<div class="line">        btCollisionShape* groundShape = <span class="keyword">new</span> btBoxShape(btVector3(btScalar(50.), btScalar(50.), btScalar(50.)));</div>
<div class="line"> </div>
<div class="line">        collisionShapes.push_back(groundShape);</div>
<div class="line"> </div>
<div class="line">        btTransform groundTransform;</div>
<div class="line">        groundTransform.setIdentity();</div>
<div class="line">        groundTransform.setOrigin(btVector3(0, -56, 0));</div>
<div class="line"> </div>
<div class="line">        btScalar mass(0.);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">//rigidbody is dynamic if and only if mass is non zero, otherwise static</span></div>
<div class="line">        <span class="keywordtype">bool</span> isDynamic = (mass != 0.f);</div>
<div class="line"> </div>
<div class="line">        btVector3 localInertia(0, 0, 0);</div>
<div class="line">        <span class="keywordflow">if</span> (isDynamic)</div>
<div class="line">            groundShape-&gt;calculateLocalInertia(mass, localInertia);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">//using motionstate is optional, it provides interpolation capabilities, and only synchronizes &#39;active&#39; objects</span></div>
<div class="line">        btDefaultMotionState* myMotionState = <span class="keyword">new</span> btDefaultMotionState(groundTransform);</div>
<div class="line">        btRigidBody::btRigidBodyConstructionInfo rbInfo(mass, myMotionState, groundShape, localInertia);</div>
<div class="line">        btRigidBody* body = <span class="keyword">new</span> btRigidBody(rbInfo);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">//add the body to the dynamics world</span></div>
<div class="line">        dynamicsWorld-&gt;addRigidBody(body);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//create a dynamic rigidbody</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">//btCollisionShape* colShape = new btBoxShape(btVector3(1,1,1));</span></div>
<div class="line">        btCollisionShape* colShape = <span class="keyword">new</span> btSphereShape(btScalar(1.));</div>
<div class="line">        collisionShapes.push_back(colShape);</div>
<div class="line"> </div>
<div class="line">        btTransform startTransform;</div>
<div class="line">        startTransform.setIdentity();</div>
<div class="line"> </div>
<div class="line">        btScalar mass(1.f);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">//rigidbody is dynamic if and only if mass is non zero, otherwise static</span></div>
<div class="line">        <span class="keywordtype">bool</span> isDynamic = (mass != 0.f);</div>
<div class="line"> </div>
<div class="line">        btVector3 localInertia(0, 0, 0);</div>
<div class="line">        <span class="keywordflow">if</span> (isDynamic)</div>
<div class="line">            colShape-&gt;calculateLocalInertia(mass, localInertia);</div>
<div class="line"> </div>
<div class="line">        startTransform.setOrigin(btVector3(2, 10, 0));</div>
<div class="line"> </div>
<div class="line">        <span class="comment">//using motionstate is recommended, it provides interpolation capabilities, and only synchronizes &#39;active&#39; objects</span></div>
<div class="line">        btDefaultMotionState* myMotionState = <span class="keyword">new</span> btDefaultMotionState(startTransform);</div>
<div class="line">        btRigidBody::btRigidBodyConstructionInfo rbInfo(mass, myMotionState, colShape, localInertia);</div>
<div class="line">        btRigidBody* body = <span class="keyword">new</span> btRigidBody(rbInfo);</div>
<div class="line"> </div>
<div class="line">        dynamicsWorld-&gt;addRigidBody(body);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; 150; i++)</div>
<div class="line">    {</div>
<div class="line">        dynamicsWorld-&gt;stepSimulation(1.f / 60.f, 10);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">//print positions of all objects</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = dynamicsWorld-&gt;getNumCollisionObjects() - 1; j &gt;= 0; j--)</div>
<div class="line">        {</div>
<div class="line">            btCollisionObject* obj = dynamicsWorld-&gt;getCollisionObjectArray()[j];</div>
<div class="line">            btRigidBody* body = btRigidBody::upcast(obj);</div>
<div class="line">            btTransform trans;</div>
<div class="line">            <span class="keywordflow">if</span> (body &amp;&amp; body-&gt;getMotionState())</div>
<div class="line">            {</div>
<div class="line">                body-&gt;getMotionState()-&gt;getWorldTransform(trans);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">                trans = obj-&gt;getWorldTransform();</div>
<div class="line">            }</div>
<div class="line">            printf(<span class="stringliteral">&quot;world pos object %d = %f,%f,%f\n&quot;</span>, j, <span class="keywordtype">float</span>(trans.getOrigin().getX()), <span class="keywordtype">float</span>(trans.getOrigin().getY()), <span class="keywordtype">float</span>(trans.getOrigin().getZ()));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">//cleanup in the reverse order of creation/initialization</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">//remove the rigidbodies from the dynamics world and delete them</span></div>
<div class="line">    <span class="keywordflow">for</span> (i = dynamicsWorld-&gt;getNumCollisionObjects() - 1; i &gt;= 0; i--)</div>
<div class="line">    {</div>
<div class="line">        btCollisionObject* obj = dynamicsWorld-&gt;getCollisionObjectArray()[i];</div>
<div class="line">        btRigidBody* body = btRigidBody::upcast(obj);</div>
<div class="line">        <span class="keywordflow">if</span> (body &amp;&amp; body-&gt;getMotionState())</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">delete</span> body-&gt;getMotionState();</div>
<div class="line">        }</div>
<div class="line">        dynamicsWorld-&gt;removeCollisionObject(obj);</div>
<div class="line">        <span class="keyword">delete</span> obj;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//delete collision shapes</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; collisionShapes.size(); j++)</div>
<div class="line">    {</div>
<div class="line">        btCollisionShape* shape = collisionShapes[j];</div>
<div class="line">        collisionShapes[j] = 0;</div>
<div class="line">        <span class="keyword">delete</span> shape;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//delete dynamics world</span></div>
<div class="line">    <span class="keyword">delete</span> dynamicsWorld;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//delete solver</span></div>
<div class="line">    <span class="keyword">delete</span> solver;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//delete broadphase</span></div>
<div class="line">    <span class="keyword">delete</span> overlappingPairCache;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//delete dispatcher</span></div>
<div class="line">    <span class="keyword">delete</span> dispatcher;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">delete</span> collisionConfiguration;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//next line is optional: it will be cleared by the destructor when the array goes out of scope</span></div>
<div class="line">    collisionShapes.clear();</div>
<div class="line">}</div>
</div><!-- fragment --><p>You can see that in the last line, we've actually created our world/simulation by creating a DiscreteDynamicsWorld (link to documentation for that) </p>
<p>On the next lines we can see how bullet deals with time through the <code>stepSimulation(...)</code> function call </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Manual</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
